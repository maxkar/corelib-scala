package io.github.maxkar
package http.server.api

import http.headers.Header

import java.nio.charset.Charset

/**
 * Routing-related functionality. "Routing" is loosely defined as "making
 * choices based on the incoming HTTP request". This covers not only the
 * "common" bits like method and path, but also more advanced concepts
 * like Content-Type based routing and Content Negotiation (both may define
 * how the processing happens). For the sake of completeness, this trait also
 * defined payload access APIs.
 *
 * The methods are usually acessed from the companion object and not from
 * typeclass instances.
 *
 * @tparam M type constructor of the execution monad.
 */
trait Route[M[_]] {
  /**
   * Routes/handles the request based on the (unconsumed) request path. The
   * implementation should abort the request (usually by returning "404 Not Found").
   *
   * @param fn function that maps request paths results.
   */
  def path[T](fn: PartialFunction[List[String], M[T]]): M[T]


  /**
   * Delegates the routing (and processing) to another handler.
   *
   * @param unconsumedPath the path (sequence of segments) that would be used
   *   by the `path` method inside the `handler`.
   */
  def continue[T](unconsumedPath: List[String], handler: M[T]): M[T]


  /**
   * Retrieves the request method.
   *
   * The "request method" is not an actual low-level (over-the-wire) method used by
   * a client but an "api-level" semantical method instead. In most cases these are
   * the same. However the server may avail of a custom header like `X-Method-Override: PATCH`
   * (with the POST being used over the wire) to support ancient HTTP libraries that
   * are not aware of such method.
   */
  def getMethod(): M[String]


  /**
   * Routes the request processing according to the request method. This call assumes that
   * the handler only routes on the "server-standard" methods. See `Route.method` (on the
   * companion object) for more details.
   *
   * The implementation should treat all the `Route.defaultMethods` as the common ones but may
   * add its own methods like PROPGET/PROPSET as well.
   */
  def method[T](fn: PartialFunction[String, M[T]]): M[T]


  /**
   * Routes the request processing according to the request method. This is similar
   * to the `method` but will also consider returning `extraMethods` in the `Allowed`
   * header if the request could not be routed according to the `fn`.
   *
   * @param customMethods custom methods supported by the handler.
   * @param fn routing function.
   */
  def customMethod[T](customMethods: Iterable[String])(fn: PartialFunction[String, M[T]]): M[T]


  /**
   * Returns a value of the header "as-on-the-wire". This return one value for every request
   * header that matches the given name. The returned value may be an empty sequence.
   */
  def getHeaders(name: String): M[Seq[String]]


  /**
   * Returns a value of the (required) header. If multiple values are present, they should
   * be concatenated with comma into one value. This should raise an error if header is absent.
   *
   * The logic is equivalent to
   * ```
   * def getHeader(name: String): M[String] =
   *   getHeaders(name) flatMap {
   *     case Seq.empty => raiseAnError(400, "bad request, missing header ${name}")
   *     case other => Monad.pure(other.mkString(","))
   *   }
   * ```
   */
  def getHeader(name: String): M[String]


  /**
   * Returns the header represented by the given "Header" model.
   * Raises an error if the header could not be parsed (this includes the
   * cases when `header.fromTransport` fails on the empty sequence).
   */
  def getHeader[T](header: Header[T]): M[T]


  /** Returns value of the header or `default` value if the header is not set. */
  def getOptHeader(name: String, defaultValue: String): M[String]


  /**
   * Returns value of the header or `default` value if the header is not set.
   * The `default` value is returned when no header present. Otherwise values are
   * parsed according to the definition of the `header` (which may cause an error).
   */
  def getOptHeader[T](header: Header[T], defaultValue: T): M[T]


  /** Returns value of the header as an option. */
  def getOptHeader(name: String): M[Option[String]]


  /**
   * Returns value of the header as an option.
   * The implementation should behave as follows:
   *  * Always invoke the `header.fromTransport`
   *  * If the above parsing is successfull - return the `Some(value)` generated by the parser.
   *  * Otherwise if the header `header.name` was not present, return `None`
   *  * Otherwise (header was present) abort processing with an error.
   */
  def getOptHeader[T](header: Header[T]): M[Option[T]]


  /** Returns names of all headers provided by the request. */
  def getHeaderNames(): M[Seq[String]]


  /** Returns cookie values for the given cookie name. */
  def getCookies(name: String): M[Seq[String]]


  /** Returns values of the given parameter (which may be extracted from both URL and request body). */
  def getParameters(name: String): M[Seq[String]]

  /**
   * Returns value of the given parameter (which may be extracted from both URL and request body).
   * Fails with 400 Bad Request if parameter is missing. Returns the first value if the same parameter
   * has multiple values.
   */
  def getParameter(name: String): M[String]

  /**
   * Returns value of the given parameter (which may be extracted from both URL and request body).
   * Return the `defaultValue` if parameter is missing. Returns the first value if the same parameter
   * has multiple values.
   */
  def getOptParameter(name: String, defaultValue: String): M[String]

  /**
   * Returns value of the given parameter (which may be extracted from both URL and request body)
   * an an option. Returns the first value if the same parameter has multiple values.
   */
  def getOptParameter(name: String): M[Option[String]]


  /**
   * Returns name of all the request parameters (which may be extracted from query and request body).
   */
  def getParameterNames(): M[Seq[String]]


  /**
   * Reads and returns request content as bytes (that are limited by the `limit` length).
   * Aborts process with HTTP code 413 "Request entity too large" if
   * data sent by the client exceeded `limit`.
   */
  def getBodyAsBytes(limit: Long): M[Array[Byte]]


  /**
   * Negotiates the option (like response content representation) from the value of the given header.
   *
   * @param header header used to extract the data.
   * @param fn function that handles the selection. It would be tried on every entity returned
   *   by the header in the **decreasing** order.
   * @param default default handler that is used when partial function does not match any passed value.
   */
  def negotiate[H: Ordering, T](
        header: Header[Seq[H]],
        fn: PartialFunction[H, M[T]],
        default: => M[T])
      : M[T]


  /**
   * Negotiates the option (like response content representation) from the value of the given header.
   * @param header header used to extract the data.
   * @param weight function used to calculate (relative) weight of the given option.
   * @param fn function that handles the selection. It would be tried on every entity returned
   *   by the header in the **decreasing** order.
   * @param default default handler that is used when partial function does not match any passed value.
   */
  def negotiateBy[H, W: Ordering, T](
        header: Header[Seq[H]],
        weight: H => W,
        fn: PartialFunction[H, M[T]],
        default: => M[T])
      : M[T]
}


object Route {
  /**
   * Default methods that are commonly used by servers and are supported by
   * many http client libraries.
   */
  val defaultMethods: Iterable[String] =
    Seq(
      "GET",
      "PUT",
      "DELETE",
      "POST",
      "OPTIONS",
      "PATCH"
    )


  /**
   * Routes/handles the request based on the (unconsumed) request path. The
   * implementation should abort the request (usually by returning "404 Not Found").
   *
   * The "unconsumed" part depends on the context where the route is being invoked.
   * For the "top-level" handlers this is just the request path (path inside the handler
   * context). For other handlers (these are the handlers invoked from the higher-level onse)
   * this is the path explicitly provided by the upper-level handler (see `continue`).
   *
   * This function is intended to be used with the partial function syntax:
   * ```
   * Route.path {
   *   case "some" :: "api" :: Nil => handleSomeApi()
   *   case "another" :: "api" :: Nil => handleAnotherApi()
   * }
   * ```
   *
   * @param fn function that maps request paths results.
   */
  inline def path[M[_], T](
        fn: PartialFunction[List[String], M[T]],
      )(using
        rt: Route[M],
      ): M[T] =
    rt.path(fn)


  /**
   * Delegates the routing (and processing) to another handler.
   *
   * This method is usually called by "top-level" request routers that delegates
   * functionality to the more specific modules. The typical code looks like
   *
   * ```
   * def route: M[Response] =
   *   Route.path {
   *     case "api" :: "v1" :: rest => Route.continue(rest)(apiV1Handler)
   *     case "api" :: "v2" :: rest => Route.continue(rest)(apiV2Handler)
   *   }
   * ```
   *
   * The handling may be as complicated as needed. For example, the router may re-write URLs
   * before handing them off to the processor:
   *
   * ```
   * def route: M[Response] =
   *   Route.path {
   *     case a@("users" :: userId :: "settings" :: settingId :: rest) => Route.continue(a)(api)
   *     case "settings" :: settingId :: "users" :: userId :: rest =>
   *        Route.continue("users" :: userId :: "settings" :: settingId :: rest)(api)
   *   }
   * ```
   *
   * The above snipper allows to interchange user and setting sections in the URL but then
   * normalizes both fo the `users/<userId>/settings/<settingId>` form for the `api` handler.
   *
   * @param unconsumedPath the path (sequence of segments) that would be used
   *   by the `path` method inside the `handler`.
   */
  inline def continue[M[_], T](
        unconsumedPath: List[String],
      )(
        handler: M[T]
      )(using
        rt: Route[M]
      ): M[T] =
    rt.continue(unconsumedPath, handler)


  /**
   * Returns the request method. In most scenarios the `Route.method` is
   * better option for routing that has proper handling for unsupported methods.
   * The `getMethod` is useful for less common scenarios like proxy where any
   * request method could be supported. The "getMethod" will be a better (more natural)
   * way to capture the method than using a "callback".
   *
   * The "request method" is not an actual low-level (over-the-wire) method used by
   * a client but an "api-level" semantical method instead. In most cases these are
   * the same. However the server may avail of a custom header like `X-Method-Override: PATCH`
   * (with the POST being used over the wire) to support ancient HTTP libraries that
   * are not aware of such method.
   */
  inline def getMethod[M[_]]()(using rt: Route[M]): M[String] =
    rt.getMethod()


  /**
   * Routes the request based on the (logical) request method. This method assumes that
   * only the **common server methods** are used for routing.
   *
   * The unmatched method should result in an error (typically 405 Method Not Allowed).
   *
   * The common methods are what the specific server instances assumes to be common
   * for the given domain. The set is usually configured at the application level. As a minimum,
   * it should include the contents of the `defaultMethods` and may extend it with
   * ones used in the app. For example, a webdav server may have `PROPGET` and `PROPSET`
   * added to the **common server methods**.
   *
   * It is **safe** to route even on non-standard method in the function, but it would
   * reduce discoverability as the uncommon method won't be returned by the `Allow` header
   * if an unsupported method is used by the client.
   *
   * The function is used as
   *
   * ```
   *   Route.method {
   *      case "GET" => doGet()
   *      case "POST" => doPost()
   *   }
   * ```
   */
  inline def method[M[_], T](
        fn: PartialFunction[String, M[T]],
      )(using
        rt: Route[M],
      ): M[T] =
    rt.method(fn)


  /**
   * Routes the request based on the (logical) request method. This method assumes that
   * only the **common server methods** are used for routing.
   *
   * The unmatched method should result in an error (typically 405 Method Not Allowed).
   *
   * The function is used as
   *
   * ```
   *   Route.customMethod(Seq("DOCUMENT", "SAMPLE")) {
   *      case "GET" => doGet()
   *      case "POST" => doPost()
   *      case "DOCUMENT" => renderServerDocumentation()
   *      case "SAMPLE" => provideCallSample()
   *   }
   * ```
   *
   * This method is mostly useful for an experimental functionality that exists in a very
   * limited scope. In the common scenario all supported methods should be registered
   * in the **common methods** set in the application server.
   *
   * @param customMethods specific methods that are not in the **common server methods** set.
   */
  inline def customMethod[M[_], T](
        customMethods: Iterable[String],
      )(
        fn: PartialFunction[String, M[T]],
      )(using
        rt: Route[M],
      ): M[T] =
    rt.method(fn)


  /**
   * Returns all the (low-level) header values for the request header
   * with the given name.
   * @return list of header values.
   */
  inline def getHeaders[M[_]](name: String)(using rt: Route[M]): M[Seq[String]] =
    rt.getHeaders(name)


  /**
   * Retutrns a value of the header or fails if the header is not set. If multiple
   * headers with the same name is present, these values are concatenated into one
   * comma-separated string. That semantics is consistent with RFC 9110 Section 5.3
   * for most common headers (with the Cookies being the only known exception).
   */
  inline def getHeader[M[_]](name: String)(using rt: Route[M]): M[String] =
    rt.getHeader(name)


  /** Retutrns Header's value according to the domain logic. */
  inline def getHeader[M[_], T](
        header: Header[T],
      )(
        using rt: Route[M],
      ): M[T] =
    rt.getHeader(header)


  /** Returns value of the header or `default` value if the header is not set. */
  inline def getOptHeader[M[_]](
        name: String,
        defaultValue: String,
      )(using
        rt: Route[M]
      ): M[String] =
    rt.getOptHeader(name, defaultValue)


  /** Returns value of the header or `default` value if the header is not set. */
  inline def getOptHeader[M[_], T](
        header: Header[T],
        defaultValue: T,
      )(using
        rt: Route[M]
      ): M[T] =
    rt.getOptHeader(header, defaultValue)


  /** Returns value of the header as an option. */
  inline def getOptHeader[M[_]](
        name: String,
      )(using
        rt: Route[M]
      ): M[Option[String]] =
    rt.getOptHeader(name)


  /** Returns value of the header as an option. */
  inline def getOptHeader[M[_], T](
        header: Header[T],
      )(using
        rt: Route[M]
      ): M[Option[T]] =
    rt.getOptHeader(header)


  /** Returns names of all headers present in the request. */
  inline def getHeaderNames[M[_]]()(implicit rt: Route[M]): M[Seq[String]] =
    rt.getHeaderNames()


  /** Return cookie values for the given cookie name. */
  inline def getCookies[M[_]](name: String)(implicit rt: Route[M]): M[Seq[String]] =
    rt.getCookies(name)


  /** Returns values of the given parameter. */
  inline def getParameters[M[_]](name: String)(implicit rt: Route[M]): M[Seq[String]] =
    rt.getParameters(name)

  /**
   * Returns value of the given parameter (which may be extracted from both URL and request body).
   * Fails if parameter is missing. Returns the first value if the same parameter has multiple values.
   */
  inline def getParameter[M[_]](name: String)(implicit rt: Route[M]): M[String] =
    rt.getParameter(name)


  /**
   * Returns value of the given parameter (which may be extracted from both URL and request body).
   * Return the `defaultValue` if parameter is missing. Returns the first value if the same parameter
   * has multiple values.
   */
  inline def getOptParameter[M[_]](
        name: String,
        defaultValue: String,
      )(using
        rt: Route[M]
      ): M[String] =
    rt.getOptParameter(name, defaultValue)


  /**
   * Returns value of the given parameter (which may be extracted from both URL and request body)
   * an an option. Returns the first value if the same parameter has multiple values.
   */
  inline def getOptParameter[M[_]](name: String)(using rt: Route[M]): M[Option[String]] =
    rt.getOptParameter(name)


  /**
   * Returns name of all the request parameters (which may be extracted from query and request body).
   */
  inline def getParameterNames[M[_]]()(using rt: Route[M]): M[Seq[String]] =
    rt.getParameterNames()


  /**
   * Reads the request body as an array of bytes that should not exceed
   * the `limit` length. Aborts processing with HTTP code 413 "Request entity
   * too large" if the data sent by the client exceeded `limit`.
   * @param limit maximal expected request length.
   * @return array of read bytes that is no longer than `length`.
   */
  inline def getBodyAsBytes[M[_]](limit: Long)(using rt: Route[M]): M[Array[Byte]] =
    rt.getBodyAsBytes(limit)


  /**
   * Negotiates the option (like response content representation) from the value of the given header.
   *
   * It may be used like
   * ```
   * Route.negotiate(Headers.Accept, produceJsonV1()) {
   *   case Accept("application/json", params, _) if parms.has("v" -> "1") => produceJsonV1()
   *   case Accept("application/json", params, _) if parms.has("v" -> "2") => produceJsonV2()
   *   case Accept("application/xml", params, _) if parms.has("v" -> "1") => produceXmlV1()
   * }
   *
   * @param header header used to extract the data.
   * @param fn function that handles the selection. It would be tried on every entity returned
   *   by the header in the **decreasing** order.
   * @param default default handler that is used when partial function does not match any passed value.
   */
  inline def negotiate[M[_], H: Ordering, T](
        header: Header[Seq[H]],
        default: => M[T]
      )(
        fn: PartialFunction[H, M[T]],
      )(using
        rt: Route[M]
      ): M[T] =
    rt.negotiate(header, fn, default)


  /**
   * Negotiates the option (like response content representation) from the value of the given header.
   * @param header header used to extract the data.
   * @param weight function used to calculate (relative) weight of the given option.
   * @param fn function that handles the selection. It would be tried on every entity returned
   *   by the header in the **decreasing** order.
   * @param default default handler that is used when partial function does not match any passed value.
   */
  inline def negotiateBy[M[_], H, W: Ordering, T](
        header: Header[Seq[H]],
        weight: H => W,
        default: => M[T],
      )(
        fn: PartialFunction[H, M[T]],
      )(using
        rt: Route[M],
      ) : M[T] =
    rt.negotiateBy(header, weight, fn, default)
}
