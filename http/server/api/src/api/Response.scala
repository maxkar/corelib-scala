package io.github.maxkar
package http.server.api

import java.nio.charset.Charset

import fun.typeclass.Monad


/** Http Response generated by the server. */
class Response(
      val status: Int,
      val headers: Response.Headers = Response.Headers.empty,
      val content: Response.Content = Response.Content.Empty,
    )


object Response:
  /** Writeable byte-oriented content body. */
  trait ByteBody:
    /**
     * Outputs the content into the given output stream according
     * to the desired output discipline.
     */
    def writeTo[M[_]: Monad](stream: ByteOutputStream[M]): M[Unit]
  end ByteBody


  /** Writeable character-oriented content body. */
  trait CharBody:
    /**
     * Outputs the content into the given output stream according
     * to the desired output discipline.
     */
    def writeTo[M[_]: Monad](stream: CharOutputStream[M]): M[Unit]
  end CharBody


  /**
   * Content that could be output by the response. In theory all the content
   * may be represented as a set of bytes (during the processing time). However
   * this may require additional memory. For example, a list of N elements would
   * require a memory amount proportional to N for the output buffer. Writing
   * things directly into output (or intermediate buffer) will require only
   * constant amount of memory.
   *
   * Character output is handled separately as the server may like to manage
   * encoding buffers internally.
   */
  enum Content:
    /** No real content to output. */
    case Empty
    /** Bytes that could be output into the stream. */
    case Bytes(body: ByteBody)
    /** Characters that should be output (and the output encoding). */
    case Chars(body: CharBody, charset: Charset)
  end Content


  /** Headers that are held by the response. */
  final class Headers(data: Map[String, (String, Seq[String])] = Map.empty):
    /**
     * Creates an iterator over entries in the headers. The iterator returns
     * header names (usually the first one if multiple headers were set) and
     * their values. The iterator guarantees that the headers are unique (
     * the lowercase forms of all keys are unique).
     */
    def entriesIterator: Iterator[(String, Seq[String])] =
      data.values.iterator


    /**
     * Appends new values and returns new headers with those extra values. Old values
     * are preserved.
     */
    def append(values: (String, String)*): Headers =
      var tmp = data
      for
        (key, value) <- values
      do
        val lowerKey = key.toLowerCase()
        tmp.get(lowerKey) match
          case None =>
            tmp = tmp + (lowerKey -> (key, Seq(value)))
          case Some((outKey, data)) =>
            tmp = tmp + (lowerKey -> (outKey, data :+ value))
      new Headers(tmp)
    end append


    /** Sets/replaces the headers with the new values. */
    def set(values: (String, String)*): Headers =
      new Headers(data ++ Headers.prepare(values))


    /** Removes headers with the given name. */
    def remove(names: String*): Headers =
      new Headers(data -- names.map(_.toLowerCase()))


    /** Removes headers encoded by the header objects. */
    @scala.annotation.targetName("removeHeaders")
    def remove(headers: Header[_]*): Headers =
      new Headers(data -- headers.map(_.name.toLowerCase()))


    /** Checks if the header with the given name is defined. */
    def has(name: String): Boolean = data.contains(name.toLowerCase())


    /** Checks if the header with the given name is defined. */
    @scala.annotation.targetName("hasHeader")
    def has(header: Header[_]): Boolean = data.contains(header.name.toLowerCase())


    /**
     * Sets the headers unless these are already set. This method is most commonly
     * used by utilities and factories that set "default" headers. For example, JSON
     * response constructor may set the `Content-Typ` header to `application/json` unless
     * something else is set by the client code.
     */
    def addIfNotSet(values: (String, String)*): Headers =
      var tmp = data
      for
        (k, v) <- values
      do
        val lowerKey = k.toLowerCase()
        if !tmp.contains(lowerKey) then
          tmp = tmp + (lowerKey -> (k, Seq(v)))
      new Headers(tmp)
    end addIfNotSet
  end Headers


  object Headers:
    /** Empty headers - no data. */
    val empty: Headers = new Headers()

    /**
     * Creates a new set of headers with the given key-value pairs.
     */
    def apply(values: (String, String)*): Headers =
      new Headers(prepare(values).toMap)


    /** Prepares headers for manipulation in the internal form. */
    private def prepare(items: Seq[(String, String)]): scala.collection.MapView[String, (String, Seq[String])] =
      items
        .groupBy(_._1.toLowerCase())
        .view
        .mapValues { entries =>
          val key = entries.head._1
          val values = entries.map(_._2)
          (key, values)
        }
    end prepare
  end Headers


  /** Creates a new response with the given status, header and content. */
  def apply(
        status: Int,
        headers: (String, String)*
      )(
        content: Content = Content.Empty
      ): Response =
    new Response(status, Headers(headers*), content)


  /**
   * Creates a "no-content" response. This is essentually a form of
   * the `apply` but having less brackets.
   */
  def noContent(
        status: Int = 204,
        headers: (String, String)*
      ): Response =
    new Response(status, Headers(headers*), Content.Empty)

end Response
