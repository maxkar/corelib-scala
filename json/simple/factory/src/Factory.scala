package io.github.maxkar
package json.simple.factory

import json.simple.Json
import json.parser.factory.JsonFactory
import json.parser.factory.TermFactory
import json.parser.factory.StringFactory
import json.parser.factory.NumberFactory
import json.parser.factory.ArrayFactory
import json.parser.factory.ObjectFactory

import fun.typeclass.Monad

/**
 * Json object/value factory compatible with the standard parser API.
 * @tparam M calculation monad.
 * @param fail failure factor - encodes/transfers text message to failure execution.
 */
final class Factory[M[+_]: Monad](
      fail: String => M[Nothing]
    ) extends JsonFactory[M, Json]:


  /**
   * Implementation of term parser.
   */
  private final class TermFactoryImpl(res: Json) extends TermFactory[M, Json]:
    override type State = Unit

    override def begin: M[State] = Monad.pure(())
    override def end(state: State): M[Json] = Monad.pure(res)

    override def badInput(startLocation: State, expectedTerm: String, offset: Int): M[Json] =
      fail("Invalid/unexpected character of the ${expectedTerm} literal")

    override def unexpectedEnd(startLocation: State, expectedTerm: String, offset: Int): M[Json] =
      fail("Unexpected end of file inside ${expectedTerm} literal")
  end TermFactoryImpl


  /**
   * String parser. It may be used in both object context and value context thus it has to adapt
   * resulting string to the requried type.
   * @tparam T type of the value generated by the factory.
   * @param convert function used to build actual value.
   */
  private final class StringFactoryImpl[T](convert: String => T) extends StringFactory[M, T]:
    override type State = StringBuilder

    override def begin: M[State] = Monad.pure(new StringBuilder())

    override def update(state: State, input: CharSequence): (State, Boolean) = {
      state.append(input)
      (state, true)
    }

    override def update(state: State, input: Char): (State, Boolean) = {
      state.append(input)
      (state, true)
    }

    override def end(state: State): M[T] =
      Monad.pure(convert(state.toString()))


    override def badEscape(state: State): M[T] =
      fail("Unexpected escaped character in string literal")

    override def badUnicodeEscape(state: State): M[T] =
      fail("Unexpected unicode escape letter in string")

    override def badUnicodeEscape(state: State, c1: Char): M[T] =
      badUnicodeEscape(state)

    override def badUnicodeEscape(state: State, c1: Char, c2: Char): M[T] =
      badUnicodeEscape(state)

    override def badUnicodeEscape(state: State, c1: Char, c2: Char, c3: Char): M[T] =
      badUnicodeEscape(state)

    override def badCharacter(state: State): M[T] =
      fail("Unexpected/illegal character in string")

    override def unterminatedString(state: State): M[T] =
      fail("Unclosed string literal in string")
  end StringFactoryImpl


  override val nullFactory: TermFactory[M, Json] = new TermFactoryImpl(Json.Null)
  override val trueFactory: TermFactory[M, Json] = new TermFactoryImpl(Json.True)
  override val falseFactory: TermFactory[M, Json] = new TermFactoryImpl(Json.False)

  override val stringFactory: StringFactory[M, Json] = new StringFactoryImpl(Json.String.apply)


  override object numberFactory extends NumberFactory[M, Json]:
    override type State = StringBuilder

    override def begin: M[State] = Monad.pure(new StringBuilder())

    override def update(state: State, input: CharSequence): (State, Boolean) = {
      state.append(input)
      (state, true)
    }

    override def end(state: State): M[Json] =
      Monad.pure(Json.Number(state.toString))

    override def missingIntDigits(state: State): M[Json] =
      fail("Missing integer part inside numeric literal")

    override def missingFractionalDigits(state: State): M[Json] =
      fail("Missing fractional digits inside numeric literal")

    override def missingExponentDigits(state: State): M[Json] =
      fail("Missing exponent digits inside numeric literal")

    override def digitsAfterLeadingZero(state: State): M[Json] =
      fail("Illegal digits after leading 0 in the numeric literal")
  end numberFactory


  override object arrayFactory extends ArrayFactory[M, Json]:
    import scala.collection.mutable.ArrayBuffer

    override type State = ArrayBuffer[Json]

    override def begin: M[State] = Monad.pure(new ArrayBuffer())

    override def update(state: State, input: Json): (State, Boolean) = {
      state.append(input)
      (state, true)
    }

    override def end(state: State): M[Json] =
      Monad.pure(Json.Array(state.toSeq))

    override def badArrayContinuation(state: State): M[Json] =
      fail("Unexpected character inside array literal, comma or end of array is expected")
  end arrayFactory


  override object objectFactory extends ObjectFactory[M, Json]:
    import scala.collection.mutable.HashMap

    override type Key = String

    /* State - current data, optional _duplicate_ key. */
    override type State = (HashMap[String, Json], Option[Key])

    override val keyFactory: StringFactory[M, String] = new StringFactoryImpl(identity)

    override def begin: M[State] = Monad.pure((new HashMap(), None))


    override def update(state: State, key: Key, value: Json): (State, Boolean) =
      if state._1.contains(key)
      then ((state._1, Some(key)), false)
      else
        state._1.put(key, value)
        (state, true)
    end update


    override def end(state: State): M[Json] =
      state._2 match
        case Some(key) =>
          fail("Duplicate key ${key} inside object")
        case None =>
          Monad.pure(Json.Object(state._1.toMap))
      end match

    override def badKeyStart(state: State): M[Json] =
      fail("Unexpected character inside object literal, key expected")


    override def badObjectContinuation(state: State): M[Json] =
      fail("Unexpected character inside object literal, comma or end of object is expected")


    override def badKeyValueSeparator(state: State, key: Key): M[Json] =
      fail("Unexpected character inside object literal, colon is expected")
  end objectFactory


  override def badValue: M[Json] =
    fail("Unexpected start of JSON value")
end Factory

